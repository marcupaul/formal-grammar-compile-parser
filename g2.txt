N = { PROGRAM, SUBPROGRAMLIST, SUBPROGRAM, ARGUMENTLIST, PRIMITIVETYPE, DECLARATIONLIST, DECLARATION, TYPE, ARRAYTYPE, COMPOUNDSTATEMENT, STATEMENTLIST, STATEMENT, SIMPLESTATEMENT, ASSIGNMENTSTATEMENT, INCREMENTSTATEMENT, EXPRESSION, TERM, IOSTATEMENT, RETURNSTATEMENT, STRUCTSTATEMENT, CONDSTATEMENT, CYCLESTATEMENT, TRAVERSESTATEMENT, COND, RELATION, FUNCTIONCONTENT }
E = { ;, (, ), {, }, identifier, <, >, {, }, ++, +++, if, then, elsecond, array, +, -, %%, ^^, cycleif, else, :, =, ==, <=, >=, <<, >>, !!, AND, OR, boolean, integer, char, string, constant, runtimeOutput, runtimeInput, traverse, send }
S = PROGRAM
P = {
	PROGRAM -> SUBPROGRAMLIST,
    SUBPROGRAMLIST -> SUBPROGRAM | SUBPROGRAM ; SUBPROGRAMLIST,
    SUBPROGRAM -> PRIMITIVETYPE identifier ( ARGUMENTLIST ) { FUNCTIONCONTENT },
    FUNCTIONCONTENT -> DECLARATIONLIST ; COMPOUNDSTATEMENT | COMPOUNDSTATEMENT,
    ARGUMENTLIST -> DECLARATION | DECLARATION ; ARGUMENTLIST,
    PRIMITIVETYPE -> boolean | integer | char | string,
    DECLARATIONLIST -> DECLARATION | DECLARATION ; DECLARATIONLIST,
    DECLARATION -> TYPE identifier,
    TYPE -> PRIMITIVETYPE | ARRAYTYPE,
    ARRAYTYPE -> array < PRIMITIVETYPE >,
    COMPOUNDSTATEMENT -> STATEMENTLIST ;,
    STATEMENTLIST -> STATEMENT | STATEMENT ; STATEMENTLIST,
    STATEMENT -> SIMPLESTATEMENT | STRUCTSTATEMENT,
    SIMPLESTATEMENT -> ASSIGNMENTSTATEMENT | INCREMENTSTATEMENT | IOSTATEMENT | RETURNSTATEMENT,
    ASSIGNMENTSTATEMENT -> identifier = EXPRESSION | DECLARATION = EXPRESSION,
    INCREMENTSTATEMENT -> ++ identifier | +++ identifier | identifier ++ | identifier +++,
    EXPRESSION -> EXPRESSION + TERM | EXPRESSION - TERM | EXPRESSION %% TERM | EXPRESSION ^^ TERM | TERM,
    TERM -> ( EXPRESSION ) | identifier | constant,
    IOSTATEMENT -> runtimeInput ( identifier ; PRIMITIVETYPE ) | runtimeOutput ( identifier ),
    RETURNSTATEMENT -> send TERM,
    STRUCTSTATEMENT -> COMPOUNDSTATEMENT | CONDSTATEMENT | CYCLESTATEMENT | TRAVERSESTATEMENT,
    CONDSTATEMENT -> if ( COND ) then { STATEMENT } elsecond ( COND ) then { STATEMENT } else { STATEMENT },
    CYCLESTATEMENT -> cycleif ( COND ) { STATEMENT },
    TRAVERSESTATEMENT -> traverse ( identifier : identifier ) { STATEMENT },
    COND -> EXPRESSION RELATION EXPRESSION,
    RELATION -> == | <= | >= | << | >> | !! | AND | OR
}